{"ast":null,"code":"/**\n * Implements Merge Sort in ascending order\n * Stable, recursive, divide & conquer, O(nlogn)\n * Works well with large datasets, if size of dataset unknown consider other alogrithm like insertion sort\n\n * @param {array} array unsorted array of doubles\n * @returns {array} ascending sorted array\n */\nfunction mergeSort(array) {\n  // recursion finished when 1 item remaining in array\n  if (array.length <= 1) {\n    return array;\n  }\n\n  // recursively call merge sort, recursively cutting array in half\n  let mid = Math.floor(array.length / 2),\n    leftArray = mergeSort(array.slice(0, mid)),\n    rightArray = mergeSort(array.slice(mid));\n\n  // use merge utility to start build arrays back up, with each merge sorting along the way\n  return mergeArray(leftArray, rightArray);\n\n  /**\n   * Implements sorting and merging of two arrays\n   * O(N), where N = max(arr1.length, arr2.length)\n   * \n   * @param {array} arr1 an array\n   * @param {array} arr2 an array\n   * @returns {array} sorted merged array\n   */\n  function mergeArray(arr1, arr2) {\n    let sorted = [];\n\n    //while there are items in either array, check which first item is smaller, add it to the sorted array, and remove it from it's original array\n    while (arr1.length && arr2.length) {\n      if (arr1[0] < arr2[0]) {\n        sorted.push(arr1.shift());\n      } else {\n        sorted.push(arr2.shift());\n      }\n    }\n\n    // If there's anything left over (ie. arrays not same size) concatonate remaining onto the end\n    return sorted.concat(arr1, arr2);\n  }\n}\n\n//test\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\nlet sorted = mergeSort(unsortedArr);\nconsole.log(sorted);","map":{"version":3,"names":["mergeSort","array","length","mid","Math","floor","leftArray","slice","rightArray","mergeArray","arr1","arr2","sorted","push","shift","concat","unsortedArr","console","log"],"sources":["/Users/aa.ron/Documents/GitHub/sorting-visualiser/src/sortingAlgorithms/sortingAlgorithms.js"],"sourcesContent":["/**\n * Implements Merge Sort in ascending order\n * Stable, recursive, divide & conquer, O(nlogn)\n * Works well with large datasets, if size of dataset unknown consider other alogrithm like insertion sort\n\n * @param {array} array unsorted array of doubles\n * @returns {array} ascending sorted array\n */\nfunction mergeSort(array) {\n\n    // recursion finished when 1 item remaining in array\n    if (array.length <= 1) {\n        return array;\n    }\n\n    // recursively call merge sort, recursively cutting array in half\n    let mid = Math.floor(array.length / 2),\n        leftArray = mergeSort(array.slice(0,mid)),\n        rightArray = mergeSort(array.slice(mid));\n    \n    // use merge utility to start build arrays back up, with each merge sorting along the way\n    return mergeArray(leftArray, rightArray);\n    \n\n    /**\n     * Implements sorting and merging of two arrays\n     * O(N), where N = max(arr1.length, arr2.length)\n     * \n     * @param {array} arr1 an array\n     * @param {array} arr2 an array\n     * @returns {array} sorted merged array\n     */\n    function mergeArray(arr1, arr2) {\n            \n        let sorted = [];\n\n        //while there are items in either array, check which first item is smaller, add it to the sorted array, and remove it from it's original array\n        while (arr1.length && arr2.length) {\n            if (arr1[0] < arr2[0]) {\n                sorted.push(arr1.shift());\n            }\n            else {\n                sorted.push(arr2.shift());\n            }\n        }\n\n        // If there's anything left over (ie. arrays not same size) concatonate remaining onto the end\n        return sorted.concat(arr1,arr2);\n    }\n\n}\n\n//test\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\nlet sorted = mergeSort(unsortedArr);\nconsole.log(sorted);"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAASA,CAACC,KAAK,EAAE;EAEtB;EACA,IAAIA,KAAK,CAACC,MAAM,IAAI,CAAC,EAAE;IACnB,OAAOD,KAAK;EAChB;;EAEA;EACA,IAAIE,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACJ,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;IAClCI,SAAS,GAAGN,SAAS,CAACC,KAAK,CAACM,KAAK,CAAC,CAAC,EAACJ,GAAG,CAAC,CAAC;IACzCK,UAAU,GAAGR,SAAS,CAACC,KAAK,CAACM,KAAK,CAACJ,GAAG,CAAC,CAAC;;EAE5C;EACA,OAAOM,UAAU,CAACH,SAAS,EAAEE,UAAU,CAAC;;EAGxC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASC,UAAUA,CAACC,IAAI,EAAEC,IAAI,EAAE;IAE5B,IAAIC,MAAM,GAAG,EAAE;;IAEf;IACA,OAAOF,IAAI,CAACR,MAAM,IAAIS,IAAI,CAACT,MAAM,EAAE;MAC/B,IAAIQ,IAAI,CAAC,CAAC,CAAC,GAAGC,IAAI,CAAC,CAAC,CAAC,EAAE;QACnBC,MAAM,CAACC,IAAI,CAACH,IAAI,CAACI,KAAK,EAAE,CAAC;MAC7B,CAAC,MACI;QACDF,MAAM,CAACC,IAAI,CAACF,IAAI,CAACG,KAAK,EAAE,CAAC;MAC7B;IACJ;;IAEA;IACA,OAAOF,MAAM,CAACG,MAAM,CAACL,IAAI,EAACC,IAAI,CAAC;EACnC;AAEJ;;AAEA;AACA,MAAMK,WAAW,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACnN,IAAIJ,MAAM,GAAGZ,SAAS,CAACgB,WAAW,CAAC;AACnCC,OAAO,CAACC,GAAG,CAACN,MAAM,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}